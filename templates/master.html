<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Master - Traduction</title>
    <script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@latest/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', path='css/msg.css') }}">
</head>
<body>

    <div class="container">
        <div id="col-fr" class="column fr-col">
        </div>
        <div id="col-es" class="column es-col">
        </div>
    </div>

    <div class="controls">
        <button id="btnStart" onclick="startRecognition()">‚ñ∂</button>
        <button id="btnStop" onclick="stopRecognition()" disabled>‚è∏</button>
    </div>


    <script>

        const DEV_MODE = "{{ DEV_MODE|tojson }}";

        const socket = io();
        let recognizer;

        async function getTokenOrRefresh() {
            try {
                const response = await fetch('/api/get-token');
                
                const data = await response.json();
        
                if (!response.ok) {
                    const errorMessage = data.error || "Erreur inconnue lors de la r√©cup√©ration du token";
                    throw new Error(errorMessage);
                }   
        
                return {
                    token: data.token,
                    region: data.region
                };
        
            } catch (error) {
                if (DEV_MODE) console.error("Erreur Critique Authentication:", error.message);
                alert("Impossible de se connecter au service vocal");
                return null;
            }
        }

        // --- Configuration Azure ---
        async function startRecognition() {

            const authdata = await getTokenOrRefresh();
            if (!authdata) return;

            const { token, region } = authdata;
            console.log('authentification r√©ussie pour la r√©gion : ' + region);

            const speechConfig = SpeechSDK.SpeechTranslationConfig.fromAuthorizationToken(token, region);

            // init de langue source pour debugger le sdk
            speechConfig.speechRecognitionLanguage = "fr-FR"; 

            // init de langues cibles
            speechConfig.addTargetLanguage("fr");
            speechConfig.addTargetLanguage("es");

            // + On active l'autod√©tection via la "Property" interne
            // Cela va SURCHARGER la langue d√©finie √† l'√©tape A une fois la requ√™te envoy√©e √† Azure
            speechConfig.setProperty(
                SpeechSDK.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, 
                "fr-FR,es-MX"
            );

            const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();


            try {
                recognizer = new SpeechSDK.TranslationRecognizer(speechConfig, audioConfig);
                
                function getDetectedLanguage(result) {
                    // On essaie de lire la propri√©t√© sp√©ciale renvoy√©e par Azure
                    const autoDetectProp = result.properties.getProperty(SpeechSDK.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguageResult);
                    
                    // Si Azure a trouv√©, on renvoie √ßa, sinon on renvoie la langue du r√©sultat standard
                    return autoDetectProp || result.language || "fr-FR";
                }
                // --- √âv√©nements ---

                // 1. En cours de parole (Interim)
                recognizer.recognizing = (s, e) => {

                    if (DEV_MODE) console.log("reconnaissance en cours de parole...");
                    // On d√©tecte la langue
                    let lang = getDetectedLanguage(e.result); // ex: fr-FR
                    let text = e.result.text;
                    let translations = e.result.translations;

                    console.log("Langue d√©tect√©e:", lang);
                    console.log("Texte:", text);
                    console.log("Traductions:", translations);

                    // Logique de filtrage (similaire au Python)
                    let textFR = "", textES = "", langsource = "";
                    
                    if (lang.includes("fr")) {
                        textFR = text;
                        textES = translations.get("es");
                        langsource = "fr";
                    } else if (lang.includes("es")) {
                        textES = text;
                        textFR = translations.get("fr");
                        langsource = "es";
                    }

                    // Envoi au serveur (Mode temporaire)
                    socket.emit('new_translation', {
                        fr: textFR,
                        es: textES,
                        langsource: langsource,
                        is_final: false,
                    });
                };

                // 2. Phrase termin√©e (Final)
                recognizer.recognized = (s, e) => {
                    if (e.result.reason == SpeechSDK.ResultReason.TranslatedSpeech) {
                        let lang = getDetectedLanguage(e.result);
                        let text = e.result.text;
                        let translations = e.result.translations;

                        console.log("Langue d√©tect√©e:", lang);
                        console.log("Texte:", text);
                        console.log("Traductions:", translations);

                        let textFR = "", textES = "";
                        if (lang.includes("fr")) {
                            textFR = text;
                            textES = translations.get("es");
                        } else if (lang.includes("es")) {
                            textES = text;
                            textFR = translations.get("fr");
                        }

                        // Envoi au serveur (Mode Final - Sera sauvegard√©)
                        socket.emit('new_translation', {
                            fr: textFR,
                            es: textES,
                            is_final: true
                        });
                    }
                };

                recognizer.canceled = (s, e) => {
                    if (DEV_MODE) console.error(`CANCELED: Reason=${e.reason}`);
                    if (e.reason === SpeechSDK.CancellationReason.Error) {
                        if (DEV_MODE) console.error(`CANCELED: ErrorCode=${e.errorCode}`);
                        if (DEV_MODE) console.error(`CANCELED: ErrorDetails=${e.errorDetails}`);
                        if (DEV_MODE) console.error("CANCELED: Avez-vous mis √† jour la cl√© d'abonnement et la r√©gion ?");
                    }
                };

                recognizer.startContinuousRecognitionAsync();

                // intervalle de renouvellement du token Azure (9 minutes)
                tokenRefreshInterval = setInterval(async () => {
                    console.log("üîÑ Renouvellement du token Azure en cours...");
                    
                    const newData = await getTokenOrRefresh();
                    
                    if (newData && newData.token) {
                        // C'est la m√©thode magique : on met √† jour le token √† la vol√©e
                        recognizer.authorizationToken = newData.token;
                        console.log("Token renouvel√© avec succ√®s sans coupure !");
                    } else {
                        console.error("√âchec du renouvellement du token");
                    }
                    
                }, 9 * 60 * 1000); // 9 minutes * 60 secondes * 1000 ms

            } catch (error) {
                if (DEV_MODE) console.error("Erreur Critique de reconnaissance:", error.message);
                alert("Impossible de d√©marrer la reconnaissance");
                return;
            }
            
            document.getElementById('btnStart').disabled = true;
            document.getElementById('btnStop').disabled = false;

            console.log("reconnaissance d√©marr√©e");
        }

        function stopRecognition() {
            recognizer.stopContinuousRecognitionAsync();
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnStop').disabled = true;

            if (tokenRefreshInterval) {
                clearInterval(tokenRefreshInterval);
                tokenRefreshInterval = null;
            }

            console.log("reconnaissance arr√™t√©e");
        }

        // --- R√©ception Socket (Pour voir ce que voient les autres) ---
        const colFr = document.getElementById('col-fr');
        const colEs = document.getElementById('col-es');


        socket.on('load_history', (history) => {
            if (DEV_MODE) console.log("Chargement de l'historique..." + JSON.stringify(history));
            history.forEach(data => addMessage(data));
        });

        socket.on('display_message', (data) => {
            console.log("Affichage du message..." + JSON.stringify(data));
            addMessage(data);
        });

        socket.on('clear_screen', () => {
            colFr.innerHTML = '';
            colEs.innerHTML = '';
        });

        function addMessage(data) {
            // Suppression des messages temporaires pr√©c√©dents
            document.querySelectorAll('.temp').forEach(e => e.remove());

            // Cr√©ation du HTML
            const divFr = document.createElement('div');
            const divEs = document.createElement('div');
            
            divFr.className = data.is_final ? 'msg' : 'msg temp';
            divEs.className = data.is_final ? 'msg' : 'msg temp';

            divFr.innerText = data.fr;
            divEs.innerText = data.es;

            // Ajout en bas (car flex-direction: column-reverse g√®re l'affichage)
            colFr.prepend(divFr);
            colEs.prepend(divEs);
        }

    </script>

</body>
</html>